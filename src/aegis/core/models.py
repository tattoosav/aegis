"""Data models for Aegis events and alerts."""

from __future__ import annotations

import json
import time
import uuid
from dataclasses import dataclass, field
from enum import Enum
from typing import Any


class SensorType(Enum):
    """Sensor module identifiers."""

    NETWORK = "network"
    PROCESS = "process"
    FILE = "file"
    EVENTLOG = "eventlog"
    THREAT_INTEL = "threat_intel"
    HARDWARE = "hardware"
    CLIPBOARD = "clipboard"

    @classmethod
    def from_string(cls, value: str) -> SensorType:
        return cls(value.lower())


class Severity(Enum):
    """Alert severity levels with numeric weights for scoring."""

    INFO = "info"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

    @property
    def weight(self) -> float:
        weights = {
            "info": 0.1,
            "low": 0.2,
            "medium": 0.5,
            "high": 0.8,
            "critical": 1.0,
        }
        return weights[self.value]

    @classmethod
    def from_string(cls, value: str) -> Severity:
        return cls(value.lower())


class AlertStatus(Enum):
    """Alert lifecycle states."""

    NEW = "new"
    INVESTIGATING = "investigating"
    RESOLVED = "resolved"
    DISMISSED = "dismissed"
    AUTO_SUPPRESSED = "auto_suppressed"


@dataclass
class AegisEvent:
    """A single event emitted by a sensor module.

    Events are the atomic unit of data in Aegis. Every sensor produces
    events that flow through the Event Engine to detection engines.
    """

    sensor: SensorType
    event_type: str
    data: dict[str, Any]
    severity: Severity = Severity.INFO
    timestamp: float = field(default_factory=time.time)
    event_id: str = field(default_factory=lambda: f"evt-{uuid.uuid4().hex[:12]}")

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "event_id": self.event_id,
            "timestamp": self.timestamp,
            "sensor": self.sensor.value,
            "event_type": self.event_type,
            "severity": self.severity.value,
            "data": self.data,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> AegisEvent:
        """Deserialize from dictionary."""
        return cls(
            event_id=d["event_id"],
            timestamp=d["timestamp"],
            sensor=SensorType.from_string(d["sensor"]),
            event_type=d["event_type"],
            severity=Severity.from_string(d["severity"]),
            data=d["data"],
        )

    def to_bytes(self) -> bytes:
        """Serialize to bytes for ZeroMQ transport."""
        return json.dumps(self.to_dict()).encode("utf-8")

    @classmethod
    def from_bytes(cls, raw: bytes) -> AegisEvent:
        """Deserialize from bytes."""
        return cls.from_dict(json.loads(raw.decode("utf-8")))


@dataclass
class Alert:
    """A security alert generated by a detection engine.

    Alerts represent potential threats that need user attention.
    They include severity, confidence, explanation, and recommended actions.
    """

    event_id: str
    sensor: SensorType
    alert_type: str
    severity: Severity
    title: str
    description: str
    confidence: float
    data: dict[str, Any]
    status: AlertStatus = AlertStatus.NEW
    timestamp: float = field(default_factory=time.time)
    alert_id: str = field(default_factory=lambda: f"alt-{uuid.uuid4().hex[:12]}")
    mitre_ids: list[str] = field(default_factory=list)
    recommended_actions: list[str] = field(default_factory=list)
    dismiss_count: int = 0

    @property
    def priority_score(self) -> float:
        """Calculate alert priority score (0-100).

        Formula: base_severity * confidence * 100
        Context and threat intel multipliers are applied by the alert manager.
        """
        base = self.severity.weight * self.confidence * 100
        return min(100.0, max(0.0, base))

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "alert_id": self.alert_id,
            "event_id": self.event_id,
            "timestamp": self.timestamp,
            "sensor": self.sensor.value,
            "alert_type": self.alert_type,
            "severity": self.severity.value,
            "title": self.title,
            "description": self.description,
            "confidence": self.confidence,
            "status": self.status.value,
            "data": self.data,
            "mitre_ids": self.mitre_ids,
            "recommended_actions": self.recommended_actions,
            "priority_score": self.priority_score,
            "dismiss_count": self.dismiss_count,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Alert:
        """Deserialize from dictionary."""
        return cls(
            alert_id=d["alert_id"],
            event_id=d["event_id"],
            timestamp=d["timestamp"],
            sensor=SensorType.from_string(d["sensor"]),
            alert_type=d["alert_type"],
            severity=Severity.from_string(d["severity"]),
            title=d["title"],
            description=d["description"],
            confidence=d["confidence"],
            status=AlertStatus(d["status"]),
            data=d["data"],
            mitre_ids=d.get("mitre_ids", []),
            recommended_actions=d.get("recommended_actions", []),
            dismiss_count=d.get("dismiss_count", 0),
        )
